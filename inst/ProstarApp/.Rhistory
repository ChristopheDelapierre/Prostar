if (NROW(rowToColMat(object, withDimnames=FALSE)) != NC) {
msg <- c(
msg, "'nrow(rowToColMat)' should be equal to the number of columns"
)
}
if (NCOL(colToRowMat(object, withDimnames=FALSE)) != NR) {
msg <- c(
msg, "'ncol(colToRowMat)' should be equal to the number of rows"
)
}
if (length(msg)) {
msg
} else TRUE
})
setMethod("show", "ExampleClass", function(object) {
callNextMethod()
cat(
"rowToRowMat has ", ncol(rowToRowMat(object)), " columns\n",
"colToColMat has ", nrow(colToColMat(object)), " rows\n",
"rowToColMat has ", ncol(rowToRowMat(object)), " columns\n",
"colToRowMat has ", ncol(rowToRowMat(object)), " rows\n",
sep=""
)
})
setReplaceMethod("rowData", "ExampleClass", function(x, ..., value) {
y <- callNextMethod() # returns a modified ExampleClass
# Do something extra here.
message("hi!\n")
y
})
original_2 <- ExampleClass(assays=list(qData=original), colData=colData, metadata = meta)
#' @export
setGeneric("rowToRowMat", function(x, ...) standardGeneric("rowToRowMat"))
## [1] "rowToRowMat"
#' @export
setGeneric("colToColMat", function(x, ...) standardGeneric("colToColMat"))
## [1] "colToColMat"
#' @export
setGeneric("rowToColMat", function(x, ...) standardGeneric("rowToColMat"))
## [1] "rowToColMat"
#' @export
setGeneric("colToRowMat", function(x, ...) standardGeneric("colToRowMat"))
setMethod("rowToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@rowToRowMat
if (withDimnames)
rownames(out) <- rownames(x)
out
})
#' @export
setMethod("colToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@colToColMat
if (withDimnames)
colnames(out) <- colnames(x)
out
})
#' @export
setMethod("rowToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@rowToColMat
if (withDimnames)
rownames(out) <- colnames(x)
out
})
#' @export
setMethod("colToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@colToRowMat
if (withDimnames)
colnames(out) <- rownames(x)
out
})
original_2 <- ExampleClass(assays=list(qData=original), colData=colData, metadata = meta)
#' @importFrom BiocGenerics NCOL NROW
setValidity2("ExampleClass", function(object) {
NR <- NROW(object)
NC <- NCOL(object)
msg <- NULL
# 1D
if (length(rowVec(object, withDimnames=FALSE)) != NR) {
msg <- c(msg, "'rowVec' should have length equal to the number of rows")
}
if (length(colVec(object, withDimnames=FALSE)) != NC) {
msg <- c(
msg, "'colVec' should have length equal to the number of columns"
)
}
# 2D
if (NROW(rowToRowMat(object, withDimnames=FALSE)) != NR) {
msg <- c(
msg, "'nrow(rowToRowMat)' should be equal to the number of rows"
)
}
if (NCOL(colToColMat(object, withDimnames=FALSE)) != NC) {
msg <- c(
msg, "'ncol(colToColMat)' should be equal to the number of columns"
)
}
if (NROW(rowToColMat(object, withDimnames=FALSE)) != NC) {
msg <- c(
msg, "'nrow(rowToColMat)' should be equal to the number of columns"
)
}
if (NCOL(colToRowMat(object, withDimnames=FALSE)) != NR) {
msg <- c(
msg, "'ncol(colToRowMat)' should be equal to the number of rows"
)
}
if (length(msg)) {
msg
} else TRUE
})
setMethod("[", "ExampleClass", function(x, i, j, drop=TRUE) {
rv <- rowVec(x, withDimnames=FALSE)
cv <- colVec(x, withDimnames=FALSE)
rrm <- rowToRowMat(x, withDimnames=FALSE)
ccm <- colToColMat(x, withDimnames=FALSE)
rcm <- rowToColMat(x, withDimnames=FALSE)
crm <- colToRowMat(x, withDimnames=FALSE)
if (!missing(i)) {
if (is.character(i)) {
fmt <- paste0("<", class(x), ">[i,] index out of bounds: %s")
i <- SummarizedExperiment:::.SummarizedExperiment.charbound(
i, rownames(x), fmt
)
}
i <- as.vector(i)
rv <- rv[i]
rrm <- rrm[i,,drop=FALSE]
crm <- crm[,i,drop=FALSE]
}
if (!missing(j)) {
if (is.character(j)) {
fmt <- paste0("<", class(x), ">[,j] index out of bounds: %s")
j <- SummarizedExperiment:::.SummarizedExperiment.charbound(
j, colnames(x), fmt
)
}
j <- as.vector(j)
cv <- cv[j]
ccm <- ccm[,j,drop=FALSE]
rcm <- rcm[j,,drop=FALSE]
}
out <- callNextMethod()
BiocGenerics:::replaceSlots(out, rowVec=rv, colVec=cv,
rowToRowMat=rrm, colToColMat=ccm,
rowToColMat=rcm, colToRowMat=crm, check=FALSE)
})
setReplaceMethod("[", c("ExampleClass", "ANY", "ANY", "ExampleClass"),
function(x, i, j, ..., value) {
rv <- rowVec(x, withDimnames=FALSE)
cv <- colVec(x, withDimnames=FALSE)
rrm <- rowToRowMat(x, withDimnames=FALSE)
ccm <- colToColMat(x, withDimnames=FALSE)
rcm <- rowToColMat(x, withDimnames=FALSE)
crm <- colToRowMat(x, withDimnames=FALSE)
if (!missing(i)) {
if (is.character(i)) {
fmt <- paste0("<", class(x), ">[i,] index out of bounds: %s")
i <- SummarizedExperiment:::.SummarizedExperiment.charbound(
i, rownames(x), fmt
)
}
i <- as.vector(i)
rv[i] <- rowVec(value, withDimnames=FALSE)
rrm[i,] <- rowToRowMat(value, withDimnames=FALSE)
crm[,i] <- colToRowMat(value, withDimnames=FALSE)
}
if (!missing(j)) {
if (is.character(j)) {
fmt <- paste0("<", class(x), ">[,j] index out of bounds: %s")
j <- SummarizedExperiment:::.SummarizedExperiment.charbound(
j, colnames(x), fmt
)
}
j <- as.vector(j)
cv[j] <- colVec(value, withDimnames=FALSE)
ccm[,j] <- colToColMat(value, withDimnames=FALSE)
rcm[j,] <- rowToColMat(value, withDimnames=FALSE)
}
out <- callNextMethod()
BiocGenerics:::replaceSlots(out, rowVec=rv, colVec=cv,
rowToRowMat=rrm, colToColMat=ccm,
rowToColMat=rcm, colToRowMat=crm, check=FALSE)
})
setMethod("rbind", "ExampleClass", function(..., deparse.level=1) {
args <- list(...)
all.rv <- lapply(args, rowVec, withDimnames=FALSE)
all.rrm <- lapply(args, rowToRowMat, withDimnames=FALSE)
all.crm <- lapply(args, colToRowMat, withDimnames=FALSE)
all.rv <- do.call(c, all.rv)
all.rrm <- do.call(rbind, all.rrm)
all.crm <- do.call(cbind, all.crm)
# Checks for identical column state.
ref <- args[[1]]
ref.cv <- colVec(ref, withDimnames=FALSE)
ref.ccm <- colToColMat(ref, withDimnames=FALSE)
ref.rcm <- rowToColMat(ref, withDimnames=FALSE)
for (x in args[-1]) {
if (!identical(ref.cv, colVec(x, withDimnames=FALSE))
|| !identical(ref.ccm, colToColMat(x, withDimnames=FALSE))
|| !identical(ref.rcm, rowToColMat(x, withDimnames=FALSE)))
{
stop("per-column values are not compatible")
}
}
old.validity <- S4Vectors:::disableValidity()
S4Vectors:::disableValidity(TRUE)
on.exit(S4Vectors:::disableValidity(old.validity))
out <- callNextMethod()
BiocGenerics:::replaceSlots(out, rowVec=all.rv,
rowToRowMat=all.rrm, colToRowMat=all.crm,
check=FALSE)
})
setMethod("cbind", "ExampleClass", function(..., deparse.level=1) {
args <- list(...)
all.cv <- lapply(args, colVec, withDimnames=FALSE)
all.ccm <- lapply(args, colToColMat, withDimnames=FALSE)
all.rcm <- lapply(args, rowToColMat, withDimnames=FALSE)
all.cv <- do.call(c, all.cv)
all.ccm <- do.call(cbind, all.ccm)
all.rcm <- do.call(rbind, all.rcm)
# Checks for identical column state.
ref <- args[[1]]
ref.rv <- rowVec(ref, withDimnames=FALSE)
ref.rrm <- rowToRowMat(ref, withDimnames=FALSE)
ref.crm <- colToRowMat(ref, withDimnames=FALSE)
for (x in args[-1]) {
if (!identical(ref.rv, rowVec(x, withDimnames=FALSE))
|| !identical(ref.rrm, rowToRowMat(x, withDimnames=FALSE))
|| !identical(ref.crm, colToRowMat(x, withDimnames=FALSE)))
{
stop("per-row values are not compatible")
}
}
old.validity <- S4Vectors:::disableValidity()
S4Vectors:::disableValidity(TRUE)
on.exit(S4Vectors:::disableValidity(old.validity))
out <- callNextMethod()
BiocGenerics:::replaceSlots(out, colVec=all.cv,
colToColMat=all.ccm, rowToColMat=all.rcm,
check=FALSE)
})
RV <- 1:10
CV <- sample(50, 7)
RRM <- matrix(runif(30), nrow=10)
CCM <- matrix(rnorm(14), ncol=7)
RCM <- matrix(runif(21), nrow=7)
CRM <- matrix(rnorm(20), ncol=10)
thing <- ExampleClass(rowVec=RV, colVec=CV,
rowToRowMat=RRM, colToColMat=CCM,
rowToColMat=RCM, colToRowMat=CRM,
assays=list(counts=matrix(rnorm(70), nrow=10)),
colData=DataFrame(whee=LETTERS[1:7]),
rowData=DataFrame(yay=letters[1:10])
)
thing
mae <- c(mae, thing=thing)
RV <- 1:10
CV <- sample(50, 7)
RRM <- matrix(runif(30), nrow=10)
CCM <- matrix(rnorm(14), ncol=7)
RCM <- matrix(runif(21), nrow=7)
CRM <- matrix(rnorm(20), ncol=10)
thing <- ExampleClass(rowVec=RV, colVec=CV,
rowToRowMat=RRM, colToColMat=CCM,
rowToColMat=RCM, colToRowMat=CRM,
assays=list(counts=matrix(rnorm(70), nrow=10)),
colData=DataFrame(whee=LETTERS[1:7]),
rowData=DataFrame(yay=letters[1:10]),
assays=list(qData=original), colData=colData, metadata = meta)
mae
utils::data(Exp1_R25_pept, package='DAPARdata')
protID <- "Protein_group_IDs"
obj <- Exp1_R25_pept[1:1000]
MShared <- BuildAdjacencyMatrix(obj, protID, FALSE)
library(DAPAR)
MShared <- BuildAdjacencyMatrix(obj, protID, FALSE)
mae <- c(mae, matAdj = MShared)
obj <- readRDS("../Downloads/__MT_Hypo.MSnset")
obj
str(obj)
mae
obj
thing
mae <- c(mae, matAdj = MShared)
mae <- c(mae, test.MSnSet = obj)
mae <- MultiAssayExperiment(experiments=list(original=obj)
)
mae
experiments(mmae
)
experiments(mae)
mae[[1]]
runApp('GitHub/Prostar/inst/ProstarApp')
runApp('GitHub/Prostar/inst/ProstarApp')
runApp('GitHub/Prostar/inst/ProstarApp')
runApp('GitHub/Prostar/inst/ProstarApp')
ll.process <- c("original", "filtered", )
runApp('GitHub/Prostar/inst/ProstarApp')
runApp('GitHub/Prostar/inst/ProstarApp')
runApp('GitHub/Prostar/inst/ProstarApp')
.PipelineTemplate <- setClass("PipelineTemplate",
slots= representation(
rowVec="integer",
colVec="integer",
rowToRowMat="matrix",
colToColMat="matrix",
rowToColMat="matrix",
colToRowMat="matrix",
indexNA = "vector",
res_AllPairwiseComparisons = "list",
name.dataset = "character",
pipeline = "character",
processes = "character"
),
contains="MultiAssayExperiment"
)
.PipelineTemplate <- setClass("PipelineTemplate",
slots= representation(
rowVec="integer",
colVec="integer",
rowToRowMat="matrix",
colToColMat="matrix",
rowToColMat="matrix",
colToRowMat="matrix",
indexNA = "vector",
res_AllPairwiseComparisons = "list",
name.dataset = "character",
pipeline = "character",
processes = "character"
),
contains="MultiAssayExperiment"
)
PipelineTemplate <- function(
rowVec=integer(0),
colVec=integer(0),
rowToRowMat=matrix(0,0,0),
colToColMat=matrix(0,0,0),
rowToColMat=matrix(0,0,0),
colToRowMat=matrix(0,0,0),
indexNA = c(),
res_AllPairwiseComparisons = list(),
name.dataset = NA_character_,
pipeline = NA_character_,
processes = c(),
...)
{
se <- SummarizedExperiment(...)
.ExampleClass(se, rowVec=rowVec, colVec=colVec,
rowToRowMat=rowToRowMat, colToColMat=colToColMat,
rowToColMat=rowToColMat, colToRowMat=colToRowMat,
indexNA=indexNA, res_AllPairwiseComparisons=res_AllPairwiseComparisons,
name.dataset=name.dataset, pipeline=pipeline, process=process)
}
#' @export
setMethod("rowVec", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@rowVec
if (withDimnames)
names(out) <- rownames(x)
out
})
#' @export
setMethod("colVec", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@colVec
if (withDimnames)
names(out) <- colnames(x)
out
})
setMethod("indexNA", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@indexNA
out
})
#' @export
setMethod("datasetName", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@datasetName
out
})
setMethod("pipelineType", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@pipelineType
out
})
#' @export
setMethod("processes", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@processes
out
})
setGeneric("rowVec", function(x, ...) standardGeneric("rowVec"))
setGeneric("colVec", function(x, ...) standardGeneric("colVec"))
setGeneric("indexNA", function(x, ...) standardGeneric("indexNA"))
setGeneric("datasetName", function(x, ...) standardGeneric("datasetName"))
setGeneric("pipelineType", function(x, ...) standardGeneric("pipelineType"))
setGeneric("processes", function(x, ...) standardGeneric("processes"))
setMethod("rowVec", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@rowVec
if (withDimnames)
names(out) <- rownames(x)
out
})
#' @export
setMethod("colVec", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@colVec
if (withDimnames)
names(out) <- colnames(x)
out
})
setMethod("indexNA", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@indexNA
out
})
#' @export
setMethod("datasetName", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@datasetName
out
})
setMethod("pipelineType", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@pipelineType
out
})
#' @export
setMethod("processes", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@processes
out
})
setGeneric("rowToRowMat", function(x, ...) standardGeneric("rowToRowMat"))
#' @export
setGeneric("colToColMat", function(x, ...) standardGeneric("colToColMat"))
#' @export
setGeneric("rowToColMat", function(x, ...) standardGeneric("rowToColMat"))
#' @export
setGeneric("colToRowMat", function(x, ...) standardGeneric("colToRowMat"))
#' @export
setGeneric("pairwiseComparisons", function(x, ...) standardGeneric("pairwiseComparisons"))
#' @export
setMethod("rowToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@rowToRowMat
if (withDimnames)
rownames(out) <- rownames(x)
out
})
#' @export
setMethod("colToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@colToColMat
if (withDimnames)
colnames(out) <- colnames(x)
out
})
#' @export
setMethod("rowToColMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@rowToColMat
if (withDimnames)
rownames(out) <- colnames(x)
out
})
#' @export
setMethod("colToRowMat", "ExampleClass", function(x, withDimnames=TRUE) {
out <- x@colToRowMat
if (withDimnames)
colnames(out) <- rownames(x)
out
})
#' @export
setMethod("pairwiseComparisons", "PipelineTemplate", function(x, withDimnames=TRUE) {
out <- x@res_AllPairwiseComparisons
out
})
#' @export
#' @importMethodsFrom SummarizedExperiment rowData
setMethod("rowData", "PipelineTemplate", function(x, ...) {
out <- callNextMethod()
# Do something extra here.
out$extra <- runif(nrow(out))
# Returning the rowData object.
out
})
shiny::runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
shiny::runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
shiny::runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
install.packages("C:/Users/sw175264/Downloads/Prostar_1.19.10.tar.gz", repos = NULL, type = "source")
install.packages('shinyjqui')
install.packages("C:/Users/sw175264/Downloads/Prostar_1.19.10.tar.gz", repos = NULL, type = "source")
library(Prostar)
Prostar()
library(Prostar)
Prostar()
install.packages("C:/Users/sw175264/Downloads/Prostar_1.17.10.tar.gz", repos = NULL, type = "source")
install.packages("C:/Users/sw175264/Downloads/Prostar_1.17.10.tar.gz", repos = NULL, type = "source")
remove.packages("Prostar", lib="~/R/R-3.6.1/library")
install.packages("C:/Users/sw175264/Downloads/Prostar_1.17.10.tar.gz", repos = NULL, type = "source")
library(Prostar)
Prostar()
setwd("~/GitHub/Prostar/inst/ProstarApp")
runApp('C:/Users/sw175264/Downloads/Prostar-c68bc5aedb966c4fa638c4da98ba7cd6a0a114ce/inst/ProstarApp')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
